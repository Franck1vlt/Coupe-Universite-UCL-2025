<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badminton</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Fonction pour charger Socket.IO de mani√®re conditionnelle -->
    <script>
        function loadSocketIO() {
            return new Promise((resolve, reject) => {
                // V√©rifier si le serveur est accessible avant de charger Socket.IO
                fetch('/socket.io/socket.io.js', { 
                    method: 'HEAD',
                    cache: 'no-store',
                    signal: AbortSignal.timeout(3000)
                })
                .then(response => {
                    if (response.ok) {
                        // Serveur accessible, charger Socket.IO
                        const script = document.createElement('script');
                        script.src = '/socket.io/socket.io.js';
                        script.onload = () => {
                            console.log('Socket.IO charg√© avec succ√®s');
                            resolve(true);
                        };
                        script.onerror = (error) => {
                            console.error('Erreur lors du chargement de Socket.IO:', error);
                            reject(error);
                        };
                        document.head.appendChild(script);
                    } else {
                        console.warn('Serveur accessible mais retourne une erreur:', response.status);
                        reject(new Error(`Erreur serveur: ${response.status}`));
                    }
                })
                .catch(error => {
                    console.error('Serveur non accessible lors de la tentative de chargement de Socket.IO:', error);
                    reject(error);
                });
            });
        }

        // Essayer de charger Socket.IO, mais continuer m√™me en cas d'√©chec
        loadSocketIO().catch(error => {
            console.warn('Application d√©marr√©e sans Socket.IO:', error);
            // Cr√©er une notification pour l'utilisateur
            document.addEventListener('DOMContentLoaded', () => {
                const offlineNotice = document.createElement('div');
                offlineNotice.id = 'offlineNotice';
                offlineNotice.innerHTML = `
                    <div style="position: fixed; bottom: 20px; right: 20px; background-color: #fff3cd; 
                         color: #856404; padding: 10px; border-radius: 4px; z-index: 1000; 
                         box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                        Mode hors ligne actif - Les donn√©es sont sauvegard√©es localement.
                        <br><small>Serveur non disponible: ${error.message}</small>
                    </div>
                `;
                document.body.appendChild(offlineNotice);
            });
        });
    </script>
<style>
    .correction-button {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #f44336;
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1000;
      transition: all 0.3s ease;
    }

    .correction-button:hover {
      transform: scale(1.1);
      background-color: #d32f2f;
    }

    .match.termin√© {
      cursor: pointer;
    }

    .match.termin√©:hover {
      border: 2px solid #f44336;
    }

    /* Style pour le statut de connexion */
    .connection-status {
        position: fixed;
        top: 20px;
        right: 100px;
        padding: 8px 12px;
        border-radius: 5px;
        font-size: 14px;
        font-weight: bold;
        z-index: 1000;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        min-width: 150px;
    }
    
    .connection-status::before {
        content: '';
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
        background-color: #f8d7da;
    }
    
    .connection-status.connected::before {
        background-color: #28a745;
    }
    
    .connection-status.offline::before {
        background-color: #ffc107;
    }
    
    .connection-status.disconnected::before {
        background-color: #dc3545;
    }
    
    .connection-status.connecting::before {
        background-color: #6c757d;
        animation: pulse 1s infinite;
    }

    /* Style pour les matchs d√©sactiv√©s mais interactifs */
    .match.disabled {
      position: relative;
    }
    
    .match.disabled::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(200, 200, 200, 0.2);
      z-index: 5;
    }
    
    /* Style pour montrer qu'un match est cliquable */
    .match {
      transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    
    .match:not(.disabled):hover {
      transform: scale(1.02);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      border: 2px solid #3498db;
      cursor: pointer;
    }
    
    .match.termin√©:hover {
      border: 2px solid #2ecc71;
    }
    
    /* Style pour le mode correction actif */
    .correction-mode-active .match {
      cursor: pointer;
      opacity: 1 !important;
    }
    
    .correction-mode-active .match:hover {
      border: 2px solid #e74c3c;
    }
  </style>
</head>
<body>
    <button id="correctionMode" class="correction-button" onclick="toggleCorrectionMode()">‚úèÔ∏è</button>
    <div class="background-lines"></div>
    <div class="container">
      <header>
        <div class="phase-selector">
          <select id="phaseSelect" class="phase-select">
            <option value="qualification-phase">Qualifications</option>
            <option value="final-phase">Phase finale</option>
            <option value="classification-phase">Matchs de classement</option>
            <option value="ranking-phase">Classement final</option>
          </select>
        </div>
        <h1>Badminton</h1>
        <div class="subtitle">Phase √† √©limination directe</div>
      </header>
        
      <div class="tournament-container">
        <!-- SECTION QUALIFICATIONS -->
        <div class="bracket phase-content" id="qualification-phase">
            <div class="round qualification-round">
            <div class="round-title">Barrages</div>
                <!-- Match 1 -->
                <div class="match-wrapper">
                    <div class="match termin√©" data-match-id="1" data-match-type="barrage">
                    <div class="team">
                        <div class="team-name">FMMS</div>
                        <div class="score">-</div>
                    </div>
                    <div class="team">
                        <div class="team-name">IESEG</div>
                        <div class="score">-</div>
                    </div>
                    <div class="match-info-container">
                        <div class="match-time">9:00</div>
                        <div class="match-status">√† venir</div>
                    </div>
                    </div>
                    <div class="connector right"></div>
                </div>
                
                <!-- Match 2 -->
                <div class="match-wrapper">
                    <div class="match termin√©" data-match-id="2" data-match-type="barrage">
                    <div class="team">
                        <div class="team-name">FGES</div>
                        <div class="score">-</div>
                    </div>
                    <div class="team">
                        <div class="team-name">FLSH</div>
                        <div class="score">-</div>
                    </div>
                    <div class="match-info-container">
                        <div class="match-time">9:00</div>
                        <div class="match-status">√† venir</div>
                    </div>
                    </div>
                    <div class="connector right"></div>
                </div>
            </div>
        </div>

        <!-- SECTION PHASE FINALE -->
        <div class="bracket phase-content" id="final-phase">
            <!-- Quarts de finale -->
            <div class="round">
            <div class="round-title">Quarts de finale</div>
            <!-- Match 1: FMMS vs FGES -->
            <div class="match-wrapper">
                <div class="match" data-match-id="3" data-match-type="quarterfinal" data-position="1">
                <div class="team">
                    <div class="team-name">ESPAS-ESTICE</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">FLD</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">9:30</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
                <div class="connector top"></div>
            </div>
            <!-- Match 2: FLD vs JUNIA -->
            <div class="match-wrapper">
                <div class="match" data-match-id="4" data-match-type="quarterfinal" data-position="2">
                <div class="team">
                    <div class="team-name">ICAM</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">9:30</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
                <div class="connector bottom"></div>
            </div>
            <!-- Match 3: FLSH vs IESEG -->
            <div class="match-wrapper">
                <div class="match" data-match-id="5" data-match-type="quarterfinal" data-position="3">
                <div class="team">
                    <div class="team-name">IKPO</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">USCHOOL</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">10:00</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
                <div class="connector top"></div>
            </div>
            <!-- Match 4: ICAM vs ESPOL -->
            <div class="match-wrapper">
                <div class="match" data-match-id="6" data-match-type="quarterfinal" data-position="4">
                <div class="team">
                    <div class="team-name">PIKTURA</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">10:00</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
                <div class="connector bottom"></div>
            </div>
            </div>
            <!-- Demi-finales -->
            <div class="round2">
            <div class="round-title">Demi-finales</div>
            <div class="match-wrapper">
                <div class="match" data-match-id="9" data-match-type="semifinal" data-position="1">
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">10:30</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
                <div class="connector top"></div>
            </div>
            <div class="match-wrapper">
                <div class="match" data-match-id="10" data-match-type="semifinal" data-position="2">
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">11:00</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
                <div class="connector bottom"></div>
            </div>
            </div>
            <!-- Finale & Petite Finale -->
            <div class="round3">
            <div class="round-title">Finale</div>
            <div class="match-wrapper">
                <div class="match" data-match-id="14" data-match-type="final" data-position="1">
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">12:00</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
            </div>
            <div class="small-final">
                <div class="round-title">Place de 3√®me</div>
                <div class="match" data-match-id="13" data-match-type="smallfinal" data-position="1">
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="team">
                    <div class="team-name">-</div>
                    <div class="score">-</div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">12:00</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
            </div>
            </div>
            <!-- Champion -->
            <div class="round4">
            <div class="round-title">Champion</div>
            <div class="trophy">
                <div class="trophy-icon">üèÜ</div>
                <div class="champion" id="champion">√Ä d√©terminer</div>
            </div>
            </div>
        </div>

        <!-- SECTION MATCHS DE CLASSEMENT -->
        <div class="bracket phase-content" id="classification-phase">
            <div class="classification-container">
            <!-- Demi-finales de classement (entre perdants des quarts) -->
            <div class="round">
                <div class="round-title">Demi-finales de classement</div>
                <div class="match-wrapper">
                <div class="match" data-match-id="7" data-match-type="classification_semifinal">
                    <div class="team"><div class="team-name">Perdant QF1</div><div class="score">-</div></div>
                    <div class="team"><div class="team-name">Perdant QF2</div><div class="score">-</div></div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">10:30</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
                <div class="match-wrapper">
                <div class="match" data-match-id="8" data-match-type="classification_semifinal">
                    <div class="team"><div class="team-name">Perdant QF3</div><div class="score">-</div></div>
                    <div class="team"><div class="team-name">Perdant QF4</div><div class="score">-</div></div>
                </div>
                <div class="match-info-container">
                    <div class="match-time">11:00</div>
                    <div class="match-status">√† venir</div>
                </div>
                </div>
            </div>
            <!-- Match pour la 5√®me place -->
            <div class="round2">
                <div class="round-title">Place de 5√®me</div>
                <div class="match-wrapper">
                    <div class="match" data-match-id="12" data-match-type="classification_final" data-position="1">
                    <div class="team">
                        <div class="team-name">-</div>
                        <div class="score">-</div>
                    </div>
                    <div class="team">
                        <div class="team-name">-</div>
                        <div class="score">-</div>
                    </div>
                    <div class="match-info-container">
                        <div class="match-time">11:30</div>
                        <div class="match-status">√† venir</div>
                    </div>
                    </div>
                </div>
            </div>
            <!-- Match pour la 7√®me place -->
            <div class="round3">
                <div class="small-final">
                    <div class="round-title">Place de 7√®me</div>
                    <div class="match" data-match-id="11" data-match-type="classification_smallfinal" data-position="1">
                    <div class="team">
                        <div class="team-name">-</div>
                        <div class="score">-</div>
                    </div>
                    <div class="team">
                        <div class="team-name">-</div>
                        <div class="score">-</div>
                    </div>
                    <div class="match-info-container">
                        <div class="match-time">11:30</div>
                        <div class="match-status">√† venir</div>
                    </div>
                    </div>
                </div>
                </div>
            </div>
        </div>
                
        <!-- SECTION CLASSEMENT FINAL -->
        <div class="bracket phase-content" id="ranking-phase">
            <div class="ranking-container">
            <div class="round-title">Classement Final Badminton</div>
            <div class="ranking-table">
                <div class="ranking-row header">
                <div class="rank">Position</div>
                <div class="teamname">√âquipe</div>
                <div class="points">Points</div>
                </div>
                <div id="rankingList">
                <!-- Rempli dynamiquement par JavaScript -->
                </div>
            </div>
            </div>
        </div>
      </div>
      <div style="text-align: center;">
          <button class="reset-button" id="resetTournament" onclick="resetTournament()">R√©initialiser le tournoi</button>
          <!--<button onclick="simulateTournament()">Simuler la comp√©tition</button>-->
          <button class="back-button" onclick="window.location.href='../index.html'">Retour</button>
      </div>
    </div>
    
    <!-- Ajouter Socket.IO avant tournament.js -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="tournament.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
          const phaseSelect = document.getElementById('phaseSelect');
          const phaseContents = document.querySelectorAll('.phase-content');
          
          phaseSelect.addEventListener('change', async function() {
            const selectedPhase = phaseSelect.value;
            phaseContents.forEach(function(content) {
              if (content.id === selectedPhase) {
                content.classList.remove('hidden');
              } else {
                content.classList.add('hidden');
              }
            });
            
            if (selectedPhase === 'ranking-phase') {
              try {
                await updateRankingDisplay();
              } catch (error) {
                console.error('Erreur lors de la mise √† jour du classement masculin:', error);
              }
            }
          });
          
          // D√©clencher l'√©v√©nement change initial de mani√®re asynchrone
          setTimeout(() => phaseSelect.dispatchEvent(new Event('change')), 0);
        });  
        
        // Ajouter au script existant
        document.addEventListener('DOMContentLoaded', function() {
            // Code existant...
            
            // Surveiller l'√©tat de la connexion au serveur
            const connectionStatus = document.getElementById('connectionStatus');
            
            function updateConnectionStatus(state) {
                if (!connectionStatus) return;
                
                connectionStatus.classList.remove('connected', 'disconnected', 'connecting', 'offline');
                
                if (state === 'connected') {
                    connectionStatus.textContent = 'Connexion: ‚úÖ';
                    connectionStatus.classList.add('connected');
                } else if (state === 'disconnected') {
                    connectionStatus.textContent = 'Connexion: ‚ùå';
                    connectionStatus.classList.add('disconnected');
                } else if (state === 'offline') {
                    connectionStatus.textContent = 'Mode hors ligne';
                    connectionStatus.classList.add('offline');
                } else {
                    connectionStatus.textContent = 'V√©rification...';
                    connectionStatus.classList.add('connecting');
                }
            }
            
            // Remplacer la v√©rification HTTP par WebSocket
            if (socket && socket.connected) {
                updateConnectionStatus('connected');
            } else {
                updateConnectionStatus('connecting');
                socket.once('connect', () => {
                    updateConnectionStatus('connected');
                });
                socket.once('connect_error', () => {
                    updateConnectionStatus('offline');
                });
            }
        });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function () {
        // Fonction pour mettre √† jour les statuts des matchs
        function updateMatchStatus(status) {
            const matches = document.querySelectorAll('.match');
            matches.forEach(match => {
                const matchStatus = match.querySelector('.match-status');
                if (!matchStatus) return;

                let text = '';
                let bgColor = '';
                let textColor = '';

                switch (status) {
                    case '√†_venir':
                        text = '√Ä venir';
                        bgColor = '#f0f0f0';
                        textColor = '#666';
                        break;
                    case 'en_cours':
                        text = 'En cours';
                        bgColor = '#fff3cd';
                        textColor = '#856404';
                        break;
                    case 'termin√©':
                        text = 'Termin√©';
                        bgColor = '#d4edda';
                        textColor = '#155724';
                        break;
                    default:
                        text = 'Inconnu';
                        bgColor = '#f8d7da';
                        textColor = '#721c24';
                }

                matchStatus.textContent = text;
                matchStatus.style.backgroundColor = bgColor;
                matchStatus.style.color = textColor;
                match.setAttribute('data-status', status);
            });
        }

        // Initialisation des statuts des matchs
        updateMatchStatus('√†_venir');
    });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // D√©tecter si la page a √©t√© recharg√©e avec un param√®tre de rafra√Æchissement
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('refresh')) {
            console.log("Rechargement forc√© d√©tect√©, mise √† jour de l'interface...");
            setTimeout(() => {
                // Forcer le rechargement de l'√©tat du tournoi
                if (typeof loadTournamentState === 'function') {
                    loadTournamentState();
                }
                
                // Recalculer les liens et mettre √† jour l'interface
                if (typeof linkWinnersAndLosers === 'function') {
                    linkWinnersAndLosers();
                }
                
                if (typeof updateUI === 'function') {
                    updateUI();
                }
                
                if (typeof updateMatchClickability === 'function') {
                    updateMatchClickability();
                }
                
                // Aller √† la phase finale
                if (phaseSelect) {
                    phaseSelect.value = 'final-phase';
                    phaseSelect.dispatchEvent(new Event('change'));
                }
            }, 500);
        }
    });

    function checkActiveMatches() {
        const activeMatches = new Set();
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('liveMatchData_match')) {
                // ... v√©rification de status "en_cours" ...
            }
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // D√©tecter si la page a √©t√© recharg√©e avec un param√®tre de rafra√Æchissement
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('refresh')) {
            console.log("Rechargement forc√© d√©tect√©, mise √† jour de l'interface...");
            
            // Restaurer les matchs termin√©s sauvegard√©s
            const savedFinishedMatches = localStorage.getItem('badminton_finishedMatches');
            const matchesToRestore = savedFinishedMatches ? JSON.parse(savedFinishedMatches) : {};
            console.log("Matchs termin√©s √† restaurer:", Object.keys(matchesToRestore));
            
            // V√©rifier si on a un statut de match termin√©
            const matchStatus = urlParams.get('matchStatus');
            const matchIdToUpdate = urlParams.get('forceClear');
            const preserveAll = urlParams.has('preserveAll');
            
            setTimeout(() => {
                // Forcer le rechargement de l'√©tat du tournoi
                if (typeof loadTournamentState === 'function') {
                    loadTournamentState();
                }
                
                // R√©cup√©rer la copie actuelle du tournoi apr√®s chargement
                const currentState = JSON.parse(localStorage.getItem('badmintonTournamentState') || '{}');
                
                // Si on a un √©tat valide et des matchs √† restaurer
                if (currentState.matches) {
                    // Restaurer tous les statuts 'termin√©'
                    let changesApplied = false;
                    
                    // Parcourir tous les matchs √† restaurer depuis badminton_finishedMatches
                    if (Object.keys(matchesToRestore).length > 0) {
                        Object.keys(matchesToRestore).forEach(matchId => {
                            if (currentState.matches[matchId]) {
                                // V√©rifier si le statut a √©t√© modifi√©
                                if (currentState.matches[matchId].status !== 'termin√©') {
                                    console.log(`Restauration du statut 'termin√©' pour match ${matchId}`);
                                    currentState.matches[matchId].status = 'termin√©';
                                    changesApplied = true;
                                }
                            }
                        });
                    }
                    
                    // Appliquer √©galement au match nouvellement termin√©
                    if (matchIdToUpdate && matchStatus === 'termine' && currentState.matches[matchIdToUpdate]) {
                        console.log(`Application du statut 'termin√©' pour match ${matchIdToUpdate}`);
                        currentState.matches[matchIdToUpdate].status = 'termin√©';
                        changesApplied = true;
                    }
                    
                    // Si preserveAll est sp√©cifi√©, v√©rifier tous les statuts termin√©s existants
                    if (preserveAll) {
                        // Cr√©er une sauvegarde de tous les matchs actuellement termin√©s
                        const newFinishedMatches = {};
                        Object.entries(currentState.matches).forEach(([id, matchData]) => {
                            if (matchData.status === 'termin√©') {
                                newFinishedMatches[id] = {status: 'termin√©'};
                                console.log(`Match ${id} ajout√© √† la sauvegarde des matchs termin√©s`);
                            }
                        });
                        
                        // Mettre √† jour la sauvegarde des matchs termin√©s
                        localStorage.setItem('badminton_finishedMatches', JSON.stringify(newFinishedMatches));
                    }
                    
                    // Sauvegarder l'√©tat mis √† jour
                    if (changesApplied) {
                        console.log("Sauvegarde de l'√©tat modifi√© avec statuts 'termin√©' restaur√©s");
                        localStorage.setItem('badmintonTournamentState', JSON.stringify(currentState));
                    }
                }
                
                // Recalculer les liens et mettre √† jour l'interface
                if (typeof linkWinnersAndLosers === 'function') {
                    linkWinnersAndLosers();
                }
                
                if (typeof updateUI === 'function') {
                    updateUI();
                }
                
                // Mise √† jour de l'interface visuelle
                document.querySelectorAll('.match').forEach(match => {
                    const matchId = match.getAttribute('data-match-id');
                    if (matchId && (matchesToRestore[matchId] || matchId === matchIdToUpdate)) {
                        const statusEl = match.querySelector('.match-status');
                        if (statusEl) {
                            statusEl.textContent = 'Termin√©';
                            statusEl.style.backgroundColor = '#d4edda';
                            statusEl.style.color = '#155724';
                        }
                        match.setAttribute('data-status', 'termin√©');
                    }
                });
                
                if (typeof updateMatchClickability === 'function') {
                    updateMatchClickability();
                }
                
                // Aller √† la phase finale
                if (phaseSelect) {
                    phaseSelect.value = 'final-phase';
                    phaseSelect.dispatchEvent(new Event('change'));
                }
            }, 500);
        }
    });
</script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Ajouter une classe au body quand le mode correction est actif
        const correctionButton = document.getElementById('correctionMode');
        if (correctionButton) {
            correctionButton.addEventListener('click', function() {
                document.body.classList.toggle('correction-mode-active');
            });
        }
        
        // Ajouter un √©couteur d'√©v√©nements global pour les clics sur les matchs
        document.addEventListener('click', function(event) {
            // Trouver le match le plus proche
            const match = event.target.closest('.match');
            if (match) {
                // Si le clic √©tait sur un match, v√©rifier s'il a un gestionnaire de clic
                if (!match._hasClickHandler) {
                    console.log("Ajout d'un gestionnaire de clic pour le match", match.getAttribute('data-match-id'));
                    match._hasClickHandler = true;
                    
                    match.addEventListener('click', function() {
                        const matchId = this.getAttribute('data-match-id');
                        if (matchId && window.tournamentState && window.tournamentState.matches && window.tournamentState.matches[matchId]) {
                            console.log(`Clic d√©tect√© sur le match ${matchId}`);
                            
                            // R√©cup√©rer les donn√©es du match
                            const matchData = window.tournamentState.matches[matchId];
                            
                            // D√©terminer si le match est jouable
                            const isPlayable = !this.classList.contains('disabled') || window.correctionModeActive;
                            
                            if (isPlayable) {
                                if (typeof window.navigateToScoring === 'function') {
                                    window.navigateToScoring(matchId);
                                } else {
                                    console.error("La fonction navigateToScoring n'est pas disponible");
                                }
                            } else {
                                if (!matchData.team1 || !matchData.team2) {
                                    alert('Ce match n\'est pas encore disponible car les √©quipes n\'ont pas encore √©t√© d√©termin√©es.');
                                } else {
                                    alert('Ce match n\'est pas encore disponible. Terminez d\'abord les matchs pr√©c√©dents.');
                                }
                            }
                        }
                    });
                }
            }
        });
    });
</script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Ajouter une fonction de v√©rification p√©riodique des matchs actifs
        function checkActiveMatches() {
            const activeMatches = new Set();
            const finishedMatches = new Set();
            
            // R√©cup√©rer d'abord tous les matchs termin√©s pour ne pas les √©craser
            if (window.tournamentState && window.tournamentState.matches) {
                Object.entries(window.tournamentState.matches).forEach(([id, match]) => {
                    if (match.status === 'termin√©') {
                        finishedMatches.add(id);
                    }
                });
            }
            
            // R√©cup√©rer √©galement les matchs termin√©s sauvegard√©s
            try {
                const savedFinishedMatches = JSON.parse(localStorage.getItem('badminton_finishedMatches') || '{}');
                Object.keys(savedFinishedMatches).forEach(id => {
                    finishedMatches.add(id);
                });
            } catch (e) {
                console.warn('Erreur lors de la lecture des matchs termin√©s sauvegard√©s:', e);
            }
            
            // Chercher les matchs actifs
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('liveMatchData_match')) {
                    try {
                        const matchId = key.replace('liveMatchData_match', '');
                        const data = JSON.parse(localStorage.getItem(key));
                        
                        // Ne pas ajouter comme actif si le match est d√©j√† marqu√© comme termin√©
                        if (data && data.status === 'en_cours' && !finishedMatches.has(matchId)) {
                            activeMatches.add(matchId);
                        }
                    } catch (e) {
                        console.warn(`Erreur lors de la lecture des donn√©es pour ${key}:`, e);
                    }
                }
            }
            
            if (activeMatches.size > 0) {
                console.log("Matchs actifs d√©tect√©s:", Array.from(activeMatches));
                
                // Mettre √† jour le statut dans l'interface
                document.querySelectorAll('.match[data-match-id]').forEach(match => {
                    const matchId = match.getAttribute('data-match-id');
                    
                    // Ne pas changer le statut des matchs termin√©s
                    if (finishedMatches.has(matchId)) {
                        return;
                    }
                    
                    if (activeMatches.has(matchId)) {
                        const statusEl = match.querySelector('.match-status');
                        if (statusEl && statusEl.textContent !== 'En cours') {
                            statusEl.textContent = 'En cours';
                            statusEl.style.backgroundColor = '#fff3cd';
                            statusEl.style.color = '#856404';
                            match.setAttribute('data-status', 'en_cours');
                            
                            // Mettre √† jour aussi dans tournamentState si disponible
                            if (window.tournamentState && window.tournamentState.matches && window.tournamentState.matches[matchId]) {
                                // Ne pas √©craser un statut 'termin√©' existant
                                if (window.tournamentState.matches[matchId].status !== 'termin√©') {
                                    window.tournamentState.matches[matchId].status = 'en_cours';
                                    if (typeof window.saveTournamentState === 'function') {
                                        window.saveTournamentState();
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // V√©rifier p√©riodiquement les matchs actifs (r√©duire la fr√©quence pour √©viter les conflits)
        setInterval(checkActiveMatches, 3000);
        
        // Ex√©cuter une premi√®re fois au chargement de la page
        setTimeout(checkActiveMatches, 1000);
    });
</script>
</body>
</html>