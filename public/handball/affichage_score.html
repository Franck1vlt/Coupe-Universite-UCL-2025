<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Affichage Score Handball</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #ffffff;
            color: #000000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .score-board {
            text-align: center;
            width: 100%;
            padding: 1.25rem;
        }

        .teams {
            display: flex;
            justify-content: space-around;
            font-size: 5em;
            margin: 1.25rem 0;
            font-weight: bold;
        }

        .score-container {
            font-size: 12em;
            font-weight: bold;
            margin: 2.5rem 0;
        }

        .score-divider {
            margin: 0 2.5rem;
            color: #000000;
        }

        .match-info {
            font-size: 3em;
            margin: 1.875rem 0;
        }

        .remaining-time {
            background-color: #000000;
            padding: 0.625rem 1.25rem;
            border-radius: 0.625rem;
            margin-right: 1.25rem;
            color: red
        }

        .match-type {
            color: #000000;
        }

        .cards {
            display: flex;
            justify-content: space-around;
            margin-top: 2.5rem;
            font-size: 2.5em;
        }

        .team-cards {
            display: flex;
            align-items: center;
            gap: 1.25rem;
        }

        .card-icon {
            width: 2.5rem;
            height: auto;
            vertical-align: middle;
        }

        .team-logo {
            width: 5rem;
            height: 5rem;
            margin: 0 1.25rem;
            object-fit: contain;
        }

        /* Animation pour les changements de score */
        .score-change {
            animation: scoreUpdate 0.5s ease-in-out;
        }

        @keyframes scoreUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Ajout d'un indicateur de mode secours */
        .fallback-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(255,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
    <div class="score-board">
        <div class="teams">
            <div class="team">
                <img src="" alt="" class="team-logo" id="logoA">
                <div id="teamAName">TEAM A</div>
            </div>
            <div class="team">
                <img src="" alt="" class="team-logo" id="logoB">
                <div id="teamBName">TEAM B</div>
            </div>
        </div>
        
        <div class="score-container">
            <span id="teamAScore">0</span>
            <span class="score-divider">-</span>
            <span id="teamBScore">0</span>
        </div>
        
        <div class="match-info">
            <span class="remaining-time" id="gameChrono">00:00</span>
            <span class="match-type" id="matchType"></span>
        </div>

        <div class="cards">
            <div class="team-cards">
                <span>ðŸŸ¨</span><span id="teamAYellowCard">0</span>
                <span>ðŸŸ¥</span><span id="teamARedCard">0</span>
            </div>
            <div class="team-cards">
                <span>ðŸŸ¨</span><span id="teamBYellowCard">0</span>
                <span>ðŸŸ¥</span><span id="teamBRedCard">0</span>
            </div>
        </div>
    </div>
    
    <!-- Indicateur de mode secours -->
    <div class="fallback-indicator" id="fallbackIndicator">Mode hors-ligne</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Variables pour stocker les donnÃ©es du match et la connexion
            let matchData = {};
            let socket;
            let localStoragePolling = null;
            const matchId = new URLSearchParams(window.location.search).get('matchId');
            const id_terrain = new URLSearchParams(window.location.search).get('id_terrain') || 8; // Handball par dÃ©faut
            let socketConnected = false;
            let useFallback = false;
            const fallbackIndicator = document.getElementById('fallbackIndicator');
            
            // Activez toujours le polling localStorage en parallÃ¨le Ã  Socket.io
            // pour assurer la synchronisation sur tous les ordinateurs
            setupLocalStoragePolling();

            // Fonction pour activer l'indicateur de mode secours
            function activateFallbackIndicator() {
                if (fallbackIndicator) {
                    fallbackIndicator.style.display = 'block';
                    setTimeout(() => {
                        fallbackIndicator.style.opacity = '0.7';
                    }, 100);
                    setTimeout(() => {
                        fallbackIndicator.style.opacity = '0';
                    }, 5000);
                    setTimeout(() => {
                        if (!useFallback) {
                            fallbackIndicator.style.display = 'none';
                        }
                    }, 5500);
                }
            }
            
            // Fonction pour Ã©tablir la connexion Socket.io
            function connectSocketIO() {
                try {
                    console.log('Tentative de connexion Socket.io...');
                    
                    // Connexion au namespace /handball avec options
                    socket = io('/handball', {
                        forceNew: true, // Force une nouvelle connexion pour Ã©viter les problÃ¨mes de multiplexage
                        reconnectionAttempts: 5, 
                        timeout: 10000,
                        reconnectionDelay: 1000,
                        reconnectionDelayMax: 5000,
                        auth: { clientType: 'display', matchId: matchId }
                    });
                    
                    // Ã‰vÃ©nement de connexion rÃ©ussie
                    socket.on('connect', function() {
                        console.log('Socket.io connectÃ©');
                        socketConnected = true;
                        
                        // S'enregistrer pour ce match spÃ©cifique
                        socket.emit('registerDisplay', {
                            matchId: matchId,
                            id_terrain: id_terrain
                        });
                        
                        // Demander les donnÃ©es actuelles du match
                        socket.emit('requestData', {
                            matchId: matchId,
                            id_terrain: id_terrain
                        });
                        
                        // Envoyer un broadcast pour informer les autres clients qu'un nouvel affichage est connectÃ©
                        socket.emit('displayConnected', {
                            matchId: matchId,
                            id_terrain: id_terrain
                        });
                    });
                    
                    // Gestion des erreurs de connexion
                    socket.on('connect_error', function(error) {
                        console.error('Erreur de connexion Socket.io:', error);
                        socketConnected = false;
                        useFallback = true;
                        activateFallbackIndicator();
                        setupLocalStoragePolling();
                    });
                    
                    // Gestion de la dÃ©connexion
                    socket.on('disconnect', function() {
                        console.log('Socket.io dÃ©connectÃ©');
                        socketConnected = false;
                        useFallback = true;
                        activateFallbackIndicator();
                        setupLocalStoragePolling();
                    });
                    
                    // Ã‰coute des mises Ã  jour de score
                    socket.on('scoreUpdate', function(data) {
                        if (data && data.matchId === matchId) {
                            console.log('Mise Ã  jour reÃ§ue via Socket.io:', data);
                            matchData = data;
                            updateDisplay();
                        }
                    });
                    
                    // Ajouter un mÃ©canisme de reconnexion
                    socket.io.on('reconnect', () => {
                        console.log('Socket.io reconnectÃ©');
                        socketConnected = true;
                        useFallback = false;
                        
                        // RÃ©enregistrer l'affichage
                        socket.emit('registerDisplay', {
                            matchId: matchId,
                            id_terrain: id_terrain
                        });
                        
                        // Demander une mise Ã  jour des donnÃ©es
                        socket.emit('requestData', {
                            matchId: matchId,
                            id_terrain: id_terrain
                        });
                    });

                    // Ajouter une gestion explicite de la reconnexion
                    socket.io.on('reconnect_attempt', (attempt) => {
                        console.log(`Tentative de reconnexion #${attempt}`);
                    });

                    socket.io.on('reconnect', () => {
                        console.log('Socket.io reconnectÃ© - rÃ©-enregistrement');
                        socket.emit('registerDisplay', {
                            matchId: matchId,
                            id_terrain: id_terrain
                        });
                    });
                    
                    return true;
                } catch (error) {
                    console.error('Erreur lors de la crÃ©ation Socket.io:', error);
                    socketConnected = false;
                    useFallback = true;
                    activateFallbackIndicator();
                    setupLocalStoragePolling();
                    return false;
                }
            }

            // Configuration du polling localStorage comme solution de secours
            function setupLocalStoragePolling() {
                // Toujours activer le polling, mÃªme si Socket.io fonctionne
                console.log('Configuration du polling localStorage');
                
                // ArrÃªter le polling existant s'il y en a un
                if (localStoragePolling) {
                    clearInterval(localStoragePolling);
                }
                
                localStoragePolling = setInterval(function() {
                    try {
                        // Essayer d'abord avec la clÃ© spÃ©cifique au match
                        let data = JSON.parse(localStorage.getItem(`liveMatchData_${matchId}`));
                        
                        // Si non trouvÃ©, essayer avec la clÃ© gÃ©nÃ©rique
                        if (!data) {
                            data = JSON.parse(localStorage.getItem('liveMatchData'));
                        }
                        
                        if (data && data.matchId == matchId) {
                            console.log('DonnÃ©es rÃ©cupÃ©rÃ©es depuis localStorage:', data);
                            matchData = data;
                            updateDisplay();
                        }
                    } catch (error) {
                        console.error('Erreur lors de la lecture de localStorage:', error);
                    }
                }, 300); // Polling plus rapide (300ms)
            }

            // Fonction pour mettre Ã  jour l'affichage
            function updateDisplay() {
                // Mise Ã  jour des Ã©quipes et du type de match
                document.getElementById('teamAName').textContent = matchData.team1 || 'TEAM A';
                document.getElementById('teamBName').textContent = matchData.team2 || 'TEAM B';
                document.getElementById('matchType').textContent = matchData.matchType || 'Match en cours';
                
                // Mise Ã  jour des logos
                const logoA = document.getElementById('logoA');
                const logoB = document.getElementById('logoB');
                
                if (matchData.team1) {
                    logoA.src = `../img/${matchData.team1}.png`;
                    logoA.onerror = () => logoA.src = '../img/default.png';
                }
                
                if (matchData.team2) {
                    logoB.src = `../img/${matchData.team2}.png`;
                    logoB.onerror = () => logoB.src = '../img/default.png';
                }
                
                // Appliquer une animation Ã  l'Ã©lÃ©ment qui a changÃ©
                const animateIfChanged = (elementId, newValue) => {
                    const element = document.getElementById(elementId);
                    if (element.textContent !== String(newValue)) {
                        element.classList.add('score-change');
                        setTimeout(() => element.classList.remove('score-change'), 500);
                    }
                    element.textContent = newValue || '0';
                };
                
                // Mise Ã  jour des scores avec animation
                animateIfChanged('teamAScore', matchData.score1);
                animateIfChanged('teamBScore', matchData.score2);
                
                // Mise Ã  jour des cartons
                document.getElementById('teamAYellowCard').textContent = matchData.yellowCards1 || '0';
                document.getElementById('teamBYellowCard').textContent = matchData.yellowCards2 || '0';
                document.getElementById('teamARedCard').textContent = matchData.redCards1 || '0';
                document.getElementById('teamBRedCard').textContent = matchData.redCards2 || '0';
                
                // Mise Ã  jour du chronomÃ¨tre
                document.getElementById('gameChrono').textContent = matchData.chrono || '00:00';
            }

            // Tenter d'Ã©tablir la connexion Socket.io, sinon utiliser localStorage
            console.log('Tentative de connexion Ã  Socket.io...');
            if (!connectSocketIO()) {
                console.log('Passage au mode localStorage');
                setupLocalStoragePolling();
            }
            
            // Ping pÃ©riodique pour maintenir la connexion active si Socket.io est utilisÃ©
            setInterval(function() {
                if (socketConnected && socket) {
                    socket.emit('ping', { 
                        matchId: matchId,
                        id_terrain: id_terrain
                    });
                }
            }, 30000);
            
            // VÃ©rifier immÃ©diatement s'il y a des donnÃ©es dans localStorage
            try {
                const initialData = JSON.parse(localStorage.getItem('liveMatchData'));
                if (initialData && initialData.matchId === matchId) {
                    console.log('DonnÃ©es initiales trouvÃ©es dans localStorage');
                    matchData = initialData;
                    updateDisplay();
                }
            } catch (error) {
                console.error('Erreur lors de la lecture des donnÃ©es initiales:', error);
            }
            
            // S'assurer que nous avons des donnÃ©es aprÃ¨s un certain temps
            setTimeout(() => {
                if (!matchData.team1) {
                    console.log('Aucune donnÃ©e disponible aprÃ¨s dÃ©lai, tentative de lecture locale');
                    setupLocalStoragePolling();
                    try {
                        const data = JSON.parse(localStorage.getItem('liveMatchData'));
                        if (data && data.matchId === matchId) {
                            matchData = data;
                            updateDisplay();
                        } else {
                            console.warn('Aucune donnÃ©e disponible dans localStorage');
                        }
                    } catch (e) {
                        console.error('Erreur lors de la rÃ©cupÃ©ration des donnÃ©es:', e);
                    }
                }
            }, 3000);
            
            // Ajouter un mÃ©canisme de rechargement pÃ©riodique forcÃ© pour assurer la synchronisation
            setInterval(() => {
                console.log('VÃ©rification pÃ©riodique des donnÃ©es');
                
                if (socketConnected && socket) {
                    socket.emit('requestData', {
                        matchId: matchId,
                        id_terrain: id_terrain
                    });
                }
                
                // On vÃ©rifie aussi localStorage dans tous les cas
                try {
                    const data = JSON.parse(localStorage.getItem('liveMatchData'));
                    if (data && data.matchId === matchId) {
                        matchData = data;
                        updateDisplay();
                    }
                } catch (e) {
                    console.error('Erreur lors de la vÃ©rification pÃ©riodique:', e);
                }
            }, 3000); // VÃ©rification toutes les 3 secondes

            // Force refresh - Actualisation pÃ©riodique de l'affichage avec dÃ©tection avancÃ©e des dÃ©synchronisations
            setInterval(function() {
                if (socketConnected) {
                    try {
                        socket.emit('ping', { 
                            matchId: matchId, 
                            timestamp: Date.now(),
                            clientData: {
                                score1: matchData.score1,
                                score2: matchData.score2,
                                timestamp: matchData.timestamp || 0
                            } 
                        });
                    } catch (err) {
                        console.error('Erreur lors du ping Socket.io:', err);
                    }
                }
                
                // VÃ©rifier localStorage aussi
                try {
                    const localData = JSON.parse(localStorage.getItem(`liveMatchData_${matchId}`)) || 
                                     JSON.parse(localStorage.getItem('liveMatchData'));
                    
                    if (localData && localData.matchId == matchId) {
                        // Comparer les timestamps pour n'utiliser que les donnÃ©es plus rÃ©centes
                        const localTimestamp = localData.timestamp || 0;
                        const currentTimestamp = matchData.timestamp || 0;
                        
                        if (localTimestamp > currentTimestamp) {
                            console.log('DonnÃ©es plus rÃ©centes trouvÃ©es dans localStorage');
                            matchData = localData;
                            updateDisplay();
                        }
                    }
                } catch (e) {
                    console.warn('Erreur lors de la lecture de localStorage:', e);
                }
            }, 2000);

            // Ajouter un gestionnaire pour les rÃ©ponses ping/pong
            socket.on('pong', function(data) {
                // Si le serveur indique qu'il a des donnÃ©es mais qu'elles sont plus rÃ©centes que les nÃ´tres,
                // demander une mise Ã  jour
                if (data.hasData && data.lastUpdateTime && (!matchData.timestamp || data.lastUpdateTime > matchData.timestamp)) {
                    console.log('DonnÃ©es sur le serveur plus rÃ©centes que les nÃ´tres, demande de mise Ã  jour');
                    socket.emit('requestData', { matchId: matchId });
                }
            });
        });
    </script>
</body>
</html>